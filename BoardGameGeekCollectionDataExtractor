<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardGameGeek Collection Data Extractor</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for longer content */
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 900px;
            box-sizing: border-box;
            margin-top: 2rem;
        }
        .input-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
            display: block;
        }
        .input-group input[type="text"] {
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            width: 100%;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out;
        }
        .input-group input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6; /* Blue focus ring */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .btn {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 0.85rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .loading-indicator {
            display: none; /* Hidden by default */
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-left: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #dc2626; /* Red */
            background-color: #fee2e2; /* Light red background */
            border: 1px solid #ef4444; /* Darker red border */
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            font-weight: 500;
            display: none; /* Hidden by default */
        }
        #outputData {
            width: 100%;
            height: 300px;
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.9rem;
            resize: vertical;
            background-color: #f9fafb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-extrabold text-center text-gray-900 mb-8">BoardGameGeek Collection Data Extractor</h1>
        <p class="text-sm text-center text-gray-500 mb-4">Note: This version uses the provided Authorization Token.</p>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
            <div class="input-group flex-grow w-full sm:w-auto">
                <label for="usernameInput" class="block text-sm">BGG Username:</label>
                <input type="text" id="usernameInput" value="" placeholder="Enter BGG username" class="mt-1">
            </div>
            <button id="fetchButton" class="btn mt-4 sm:mt-0">
                Fetch Collection
                <div id="loadingSpinner" class="loading-indicator"></div>
            </button>
        </div>

        <div id="errorMessage" class="error-message"></div>

        <textarea id="outputData" readonly class="hidden"></textarea>

        <div id="gamesContainer" class="mt-8">
            <p class="text-center text-gray-500">Enter a username and click "Fetch Collection" to see your games.</p>
        </div>
    </div>

    <script>
        // --- AUTHORIZATION SETUP (User Requested) ---
        // Token provided by the user and included in the HTTP Authorization header.
        const AUTHORIZATION_TOKEN = "6a4d6168-5e9a-4f61-b87a-bca4b71bb3a9";
        
        // Headers object to include the Authorization token
        const AUTH_HEADERS = {
            'Authorization': `Bearer ${AUTHORIZATION_TOKEN}`,
        };
        // ---------------------------------------------

        // Get DOM elements
        const usernameInput = document.getElementById('usernameInput');
        const fetchButton = document.getElementById('fetchButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const gamesContainer = document.getElementById('gamesContainer');
        const errorMessage = document.getElementById('errorMessage');
        const outputData = document.getElementById('outputData');

        // Base URLs for BoardGameGeek API
        const BGG_API_COLLECTION_URL = 'https://boardgamegeek.com/xmlapi2/collection'; 
        const BGG_API_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';
        
        // Recommended delay between API calls based on BGG API guide (5 seconds)
        const API_CALL_DELAY = 5000; 

        /**
         * Encapsulates a string in double quotes and escapes internal double quotes.
         * @param {string} value - The string value to process.
         * @returns {string} The quoted and escaped string.
         */
        function escapeAndQuoteForTSV(value) {
            if (value === null || value === undefined) {
                value = '';
            }
            const escapedValue = String(value).replace(/"/g, '""');
            return `"${escapedValue}"`;
        }

        /**
         * Displays an error message to the user.
         * @param {string} message - The error message to display.
         */
        function showErrorMessage(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        /**
         * Hides the error message.
         */
        function hideErrorMessage() {
            errorMessage.style.display = 'none';
        }

        /**
         * Shows the loading spinner and disables the fetch button.
         */
        function showLoading() {
            loadingSpinner.style.display = 'inline-block';
            fetchButton.disabled = true;
            fetchButton.classList.add('opacity-70', 'cursor-not-allowed');
            gamesContainer.innerHTML = ''; 
            outputData.classList.add('hidden'); 
            hideErrorMessage();
        }

        /**
         * Hides the loading spinner and enables the fetch button.
         */
        function hideLoading() {
            loadingSpinner.style.display = 'none';
            fetchButton.disabled = false;
            fetchButton.classList.remove('opacity-70', 'cursor-not-allowed');
        }

        /**
         * Fetches the user's board game collection from BGG (single attempt).
         * @param {string} username - The BGG username.
         * @returns {Promise<Array<{id: string}>>} - A promise that resolves to an array of game IDs.
         */
        async function fetchCollection(username) {
            const url = `${BGG_API_COLLECTION_URL}?username=${username}&stats=0`; 
            console.log('Fetching collection from URL:', url);
            
            try {
                // Perform single fetch attempt with Auth Headers
                const response = await fetch(url, { headers: AUTH_HEADERS });
                const text = await response.text(); 
                
                if (response.status === 202) {
                    showErrorMessage(`BGG API is busy. The request was queued (Status 202). Please wait 30 seconds and try again.`);
                    return [];
                }

                if (!response.ok) {
                    console.error(`HTTP error fetching collection: Status ${response.status} - ${response.statusText}`);
                    
                    if (response.status === 404) { 
                        // --- USERNAME EXISTENCE CHECK ---
                        showErrorMessage(`Error: BGG Username "${username}" does not exist, or the collection is private (Status 404).`);
                    } else if (response.status === 401 || response.status === 403) {
                        showErrorMessage(`Authorization failed (Status ${response.status}). Check your token or API permissions.`);
                    } else {
                        showErrorMessage(`BGG API server error (Status: ${response.status}). The server might be temporarily overloaded.`);
                    }
                    return [];
                }
                
                // Successful response (200 OK)
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "application/xml");

                const errorElement = xmlDoc.querySelector('error');
                if (errorElement) {
                    const errorMessageText = errorElement.textContent || 'Unknown API error.';
                    showErrorMessage(`BGG API Error: ${errorMessageText}`);
                    return [];
                }

                const items = xmlDoc.querySelectorAll('item');
                if (items.length === 0) {
                    const collectionElement = xmlDoc.querySelector('items');
                    if (collectionElement && collectionElement.hasAttribute('totalitems') && collectionElement.getAttribute('totalitems') === '0') {
                        showErrorMessage(`The collection for "${username}" is empty.`);
                    } else {
                        showErrorMessage(`No games or expansions found or collection is private for username: "${username}".`);
                    }
                    return [];
                }

                const gameIds = [];
                items.forEach(item => {
                    const objectId = item.getAttribute('objectid');
                    if (objectId) {
                        gameIds.push({ id: objectId }); // Only store ID
                    }
                });
                return gameIds; 

            } catch (error) {
                console.error('Network error during collection fetch:', error);
                showErrorMessage(`A network error occurred (e.g., connection issue or timeout): ${error.message}.`);
                return [];
            }
        }

        /**
         * Fetches detailed information for a list of game IDs from BGG in chunks (single attempt per chunk).
         * @param {Array<{id: string}>} gamesWithIds - An array of game objects with ID.
         */
        async function fetchGameDetails(gamesWithIds) {
            if (gamesWithIds.length === 0) {
                return [];
            }

            const allGames = [];
            const chunkSize = 20; 
            
            for (let i = 0; i < gamesWithIds.length; i += chunkSize) {
                const chunk = gamesWithIds.slice(i, i + chunkSize);
                const idsString = chunk.map(game => game.id).join(','); 
                const url = `${BGG_API_THING_URL}?id=${idsString}&stats=0&videos=0&marketplace=0&versions=0&comments=0&ratingcomments=0`;
                console.log(`Fetching game details chunk ${Math.floor(i/chunkSize) + 1} from URL: ${url}`); 
                
                try {
                    // Perform single fetch attempt with Auth Headers
                    const response = await fetch(url, { headers: AUTH_HEADERS });
                    const text = await response.text();

                    if (!response.ok) {
                        console.error(`Failed to fetch game details chunk (HTTP status ${response.status}). Skipping this chunk.`);
                        continue; // Skip this chunk and move to the next iteration
                    }
                    
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(text, "application/xml");

                    const items = xmlDoc.querySelectorAll('item');
                    items.forEach(item => {
                        const id = item.getAttribute('id');
                        const bggItemType = item.getAttribute('type'); 
                        const nameElement = item.querySelector('name[type="primary"]');
                        const descriptionElement = item.querySelector('description');
                        const imageElement = item.querySelector('image');

                        if (bggItemType === 'boardgame' || bggItemType === 'boardgameexpansion') {
                            const name = nameElement ? nameElement.getAttribute('value') : 'N/A';
                            let description = descriptionElement ? descriptionElement.textContent : '';
                            const imageUrl = imageElement ? imageElement.textContent : '';

                            // Extracing and joining all relevant links/attributes
                            const extractLinks = (type) => [...item.querySelectorAll(`link[type="${type}"]`)].map(link => link.getAttribute('value')).join(', ');
                            
                            const categoriesString = extractLinks('boardgamecategory'); 
                            const mechanismsString = extractLinks('boardgamemechanic'); 
                            const designersString = extractLinks('boardgamedesigner');
                            const artistsString = extractLinks('boardgameartist');     
                            const publishersString = extractLinks('boardgamepublisher');
                            
                            // Specific families extraction logic (retained)
                            const families = [];
                            item.querySelectorAll('link[type="boardgamefamily"]').forEach(link => {
                                families.push(link.getAttribute('value'));
                            });
                            const familiesString = families.join(', ');


                            if (id && name !== 'N/A') { 
                                // Clean description (remove HTML tags and extra whitespace)
                                const textarea = document.createElement('textarea');
                                textarea.innerHTML = description;
                                description = textarea.value;
                                description = description.replace(/<[^>]*>/g, '').replace(/\s*\n\s*/g, ' ').trim();

                                allGames.push({ 
                                    id, name, description, imageUrl, categories: categoriesString, mechanisms: mechanismsString, 
                                    families: familiesString, designers: designersString, artists: artistsString, publishers: publishersString
                                });
                            }
                        }
                    });

                } catch (error) {
                    console.error(`Network or parsing error for game details chunk:`, error);
                    continue; // Move to the next chunk
                }

                // Delay between chunks is kept to respect BGG API rate limits
                if ((i + chunkSize) < gamesWithIds.length) { 
                    await new Promise(resolve => setTimeout(resolve, API_CALL_DELAY)); 
                }
            }
            return allGames;
        }

        /**
         * Displays the fetched board game information in a copy-paste friendly TSV format.
         */
        function displayGames(games) {
            gamesContainer.innerHTML = ''; 
            outputData.value = ''; 
            outputData.classList.remove('hidden'); 

            if (games.length === 0) {
                gamesContainer.innerHTML = '<p class="text-center text-gray-500">No game data was returned.</p>';
                outputData.classList.add('hidden');
                return;
            }

            // Create header row for TSV
            let tsvContent = `${escapeAndQuoteForTSV("Game Name")}\t${escapeAndQuoteForTSV("Description")}\t${escapeAndQuoteForTSV("Image URL")}\t${escapeAndQuoteForTSV("Category")}\t${escapeAndQuoteForTSV("Mechanism")}\t${escapeAndQuoteForTSV("Family")}\t${escapeAndQuoteForTSV("Designer")}\t${escapeAndQuoteForTSV("Artist")}\t${escapeAndQuoteForTSV("Publisher")}\n`;

            games.forEach(game => {
                const gameName = escapeAndQuoteForTSV(game.name);
                const description = escapeAndQuoteForTSV(game.description);
                const imageUrl = escapeAndQuoteForTSV(game.imageUrl);
                const categories = escapeAndQuoteForTSV(game.categories); 
                const mechanisms = escapeAndQuoteForTSV(game.mechanisms); 
                const families = escapeAndQuoteForTSV(game.families); 
                const designers = escapeAndQuoteForTSV(game.designers); 
                const artists = escapeAndQuoteForTSV(game.artists);     
                const publishers = escapeAndQuoteForTSV(game.publishers); 

                tsvContent += `${gameName}\t${description}\t${imageUrl}\t${categories}\t${mechanisms}\t${families}\t${designers}\t${artists}\t${publishers}\n`;
            });

            outputData.value = tsvContent;
        }

        /**
         * Main function to handle the fetch process.
         */
        async function handleFetchCollection() {
            showLoading();
            const username = usernameInput.value.trim();

            if (!username) {
                showErrorMessage('Please enter a BGG username.');
                hideLoading();
                return;
            }

            try {
                // Single attempt to fetch collection
                const gameIds = await fetchCollection(username); 
                
                if (gameIds.length > 0) {
                    // Always pause between collection and details fetch
                    await new Promise(resolve => setTimeout(resolve, API_CALL_DELAY)); 
                    const games = await fetchGameDetails(gameIds); 
                    displayGames(games);
                } else {
                    displayGames([]); 
                }
            } catch (error) {
                console.error('An unhandled critical error occurred:', error);
                
                if (!errorMessage.style.display || errorMessage.style.display === 'none') {
                    showErrorMessage(`A critical error occurred: ${error.message}`);
                }
            } finally {
                hideLoading();
            }
        }

        // Add event listeners
        fetchButton.addEventListener('click', handleFetchCollection);

        // Add event listener for 'keydown' on the username input
        usernameInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); 
                handleFetchCollection();
            }
        });

    </script>
</body>
</html>
